# URLshortening-distributed-system

## Overview
This project implements a scalable URL shortening service utilizing a distributed system architecture. It utilizes FastAPI for the server-side implementation and provides a React-based client-side application for seamless user interaction. The project's database is hosted on MongoDB, ensuring efficient data management and retrieval. Furthermore, the entire system is containerized using Docker, facilitating easy deployment and maintenance across various environments.

## Schema and Models

- Schemas, located in the [schema directory](https://github.com/divaamahajan/URLshortening-distributed-system/tree/main/server/schema), define the structure of documents in the database. They specify fields, data types, and validation rules.
- Models, located in the [models directory](https://github.com/divaamahajan/URLshortening-distributed-system/tree/main/server/models), represent and interact with data stored in MongoDB collections. They encapsulate CRUD operations and data validation logic.

## API Endpoints

API endpoints are defined in the [`routes.route` module](server/routes/route.py). When the FastAPI application is running, it automatically generates interactive documentation for the API. This documentation can be accessed at [http://localhost:8000/docs](http://localhost:8000/docs) in your web browser. It provides details about the endpoints, input parameters, and response formats, allowing users to explore and test the API interactively.

This FastAPI application provides the following API endpoints:

1. **Shorten URL Endpoint**:
   - **Method**: POST
   - **Path**: `/longurl`
   - **Description**: This endpoint shortens a long URL provided in the request body to a shorter version. If the long URL has already been shortened, it returns the existing short URL.
   - **Request Body**: 
     ```json
     {
       "long_url": "https://example.com/very-long-url-to-shorten"
     }
     ```
   - **Response**: 
     ```json
     {
       "shortenedUrl": "http://localhost:8000/<short_url>"
     }
     ```
   
2. **Redirect to Long URL Endpoint**:
   - **Method**: GET
   - **Path**: `/{short_url}`
   - **Description**: This endpoint redirects the client to the original long URL associated with the provided short URL.
   - **Parameters**: 
     - `short_url`: The short URL generated by the `/longurl` endpoint.
   - **Response**: Redirects the client to the original long URL.

To use these endpoints, send requests to the appropriate URL with the specified method and payload, and the backend server will respond accordingly.


## Prerequisites

### 1. Setting up MongoDB Atlas Database

1. **Create MongoDB Atlas Account:** Sign up for a MongoDB Atlas account on [cloud.mongodb.com](https://cloud.mongodb.com/).
2. **Set up a Cluster:** Create a free cluster, choose your preferred cloud provider (AWS, etc.), select a region, and set a username/password for database access.
3. **Configure Environment Variables:** Create a `.env` file in the project root directory and add the following variables:
   ```
   MONGODB_USERNAME="your_username"
   MONGODB_PASSWORD="your_password"
   ```
   Replace `your_username` and `your_password` with the credentials you set up earlier.

   > Ensure that the MongoDB Atlas cluster is properly configured and accessible before running the backend server.

#### Database Configuration

Database configuration is managed in the [configs.database](server/config/database.py) module. To obtain a MongoDB Atlas connection string:
1. Go to the MongoDB Atlas web interface.
2. Locate the cluster you want to connect to.
3. Click the Connect button next to the cluster name.
4. Choose your connection method.
5. Copy the connection string and update the `uri` in the [database file](server/config/database.py).

   > The FastAPI application uses this connection string to connect to the MongoDB Atlas cluster.

### [2. Running the Apps Locally (Option 1)](#if-you-want-to-test-application-locally-without-docker-containers)


1. **Install Python:** Set up Python for the FastAPI backend server.
2. **Install Node.js and npm:** Ensure that you have Node.js and npm installed for the React frontend client. You can download and install Node.js from [Node.js Downloads](https://nodejs.org/en/download/). npm is included with Node.js.
3. **Install Memcached:** Install Memcached for caching functionality and start it using `memcached` command.

### 3. [Dockerizing](#dockerising) or [Orchestration](#deploying-the-services-in-kubernetes-using-helm) (Option 2)

- **Sign up and Install DockerHub:** Sign up for DockerHub and install Docker for containerization and orchestration capabilities.


## If you want to test application locally without docker containers
### 1. Run the backend Server (locally without docker)

Navigate to the [server directory](server)
**a. Create virtual environment**
   - Run the following command to create a virtual environment named `venv`:
   ```
   python3 -m venv venv
   ```
- Once the virtual environment is created, you need to activate it. 

   - **On macOS and Linux**:
     ```
     source venv/bin/activate
     ```

   - **On Windows**:
     ```
     venv\Scripts\activate
     ```
-  After activation, you should see `(venv)` at the beginning of your command prompt, indicating that the virtual environment is active.
-  *When you're done working in the virtual environment, you can deactivate it by running the `deactivate` command in the terminal.*
**b. Install Dependencies**

Run the following command to install the required Python dependencies:

```
pip install -r requirements.txt
```

**c. Start FastAPI Server**

1.  update `memcache_host` of cache in [cache config file](server/config/cache.py) file to connect to memcache running at http://localhost:11211
  
```bash
   memcache_host = 'localhost'
```
2. Run the following command to start the FastAPI server on port 8000:

```
uvicorn main:app --reload
```

- The server is now running on [http://localhost:8000](http://localhost:8000)
- The `uvicorn` command is used to run the ASGI server. It automatically reloads the server when changes are detected in the source code.
- The main file used by `uvicorn` to run the server is `main.py`. [main-server](server/main.py) python file.


### 2. Client Setup (locally without docker)

Navigate to the [client directory](client)

**a. Install Dependencies**

Run the following command to install the required Node.js dependencies for the client:

```
npm install
```

**b. Start Client**
1.  update proxy key in [package.json](client/package.json) file to connect to server (backend) API running at http://localhost:8000
  
```bash
   "proxy": "http://localhost:8000",
```


2. Run the following command to start the client application on port 3000:

```
npm start
```

- The client is now running on [http://localhost:3000](http://localhost:3000) and you can start interacting with you application through this link

## Dockerising

Here's how you can create Dockerfiles for both the client and server components of your URL shortening distributed system:

1. [Dockerfile for Server (FastAPI Backend)](client/Dockerfile)

2. [Dockerfile for Client (React Frontend)](server/Dockerfile)

### Building and Running Docker Images

- Docker Compose is primarily used for orchestrating containers and defining multi-container applications on a single host or in a local development environment.

**Step 1.**  Update `memcache_host` of cache in [cache config file](server/config/cache.py) file to connect to memcached running at http://memcachedcontainer:11211
  
```bash
   memcache_host = 'memcachedcontainer'
```
This container name is given in  [`docker-compose.yaml`](docker-compose.yaml) file under the service named `memcached`, where we specified that the container created from this service should be named `memcachedcontainer`. This naming convention can be helpful for identifying and managing containers when working with Docker.

**Step 2.** Update client's proxy key in [package.json](client/package.json) file to connect to server (backend) container's API   
```bash
   "proxy": "http://servercontainer:8000",
```
#### Option 1: Docker Compose
This container name is given in  [`docker-compose.yaml`](docker-compose.yaml) file under `services` key, under the service named `server`, where we specified that the container created from this service should be named `servercontainer`. This naming convention can be helpful for identifying and managing containers when working with Docker.
    
**Step 3.** Execute the following command to run both server and client containers using `docker-compose`:

```bash
docker-compose up -d
```


#### Option 2: Manual Docker Build and Run
##### Building Docker Images:
**Step 3.** Navigate to the `root directory`  and run the following commands to build the Docker images:

```bash

# Build the server image
docker build -t serverimage ./server

# Build the client image
docker build -t clientimage ./client

# Pull Memcache Image
docker pull memcached
```

##### Running Docker Containers locally:

**Step 4.** After building the Docker images, you can run containers from these images using the following options:

```bash
# Create a custom network
docker network create mynetwork

# Running the Cache server
docker run --name memcachedcontainer -d --network mynetwork memcached

# Running the Backend Server:
docker run -d -p 8000:8000 --name servercontainer --network mynetwork --env-file ./server/.env serverimage

# Running the Frontend Client
docker run -d -p 3000:3000 --name clientcontainer --network mynetwork --link servercontainer:server clientimage
```

- This command maps port 8000 of the host to port 8000 of the container for the server, and port 3000 of the host to port 3000 of the container for the client.

---

These Dockerfiles enable you to containerize both the server (FastAPI backend) and the client (React frontend) components of your URL shortening distributed system.
Now you can access the application on your `DNS` or `localhost` on port `3000` ex:- [http://localhost:3000/](http://localhost:3000/)

## Deploying the services in Kubernetes using Helm
A Helm chart is a package format for Kubernetes applications. It contains all the Kubernetes manifest files (such as Deployments, Services, ConfigMaps, etc.) necessary to deploy and manage a specific application or service in a Kubernetes cluster. Helm charts are used to streamline the process of deploying complex applications in Kubernetes by encapsulating all the required configuration and dependencies into a single package.

In short, a Helm chart can be compared to Docker Compose in the sense that both are tools used for deploying and managing applications, but they operate at different levels:
-- Docker Compose orchestrates containers for multi-container applications locally. Helm charts deploy applications in Kubernetes, simplifying management in distributed environments. 
-- Docker Compose handles application-level orchestration, while Helm charts manage deployment and dependencies at the Kubernetes infrastructure level.


### 1. Building Docker Images:

**Step 1.**  Update `memcache_host` of cache in [cache config file](server/config/cache.py) file to connect to memcached
  
```bash
   memcache_host = 'urlcache-service-urlcache-helm.urlcache-namespace.svc.cluster.local'
```
This memcached service name and namespace is created while [creating server's helm chart](#2.-create-helm-chart). This naming convention can be helpful for identifying and managing containers when working with Kubernetes.

**Step 2.**  Update client's proxy key in [package.json](client/package.json) file to connect to server (backend) container's API   
```bash
  "proxy": "http://urlserver-service-urlserver-helm.urlserver-namespace.svc.cluster.local:8000",
```
This backend service name and namespace is created while [creating server's helm chart](#2.-create-helm-chart). This naming convention can be helpful for identifying and managing containers when working with Kubernetes.


*Same as **Step 3**  from [Building Docker Images](#building-docker-images) manually above*
**Step 3** Navigate to the `root directory`  and run the following commands to build the Docker images:

```bash

# Build the server image
docker build -t serverimage ./server

# Build the client image
docker build -t clientimage ./client

# Pull Memcache Image
docker pull memcached
```

### 2. Create helm chart 
*Make sure kubernetes is enabled in your dockerhub settings*
**a. for memcached**
1. Navigate to backend server's [server/helm/urlcache-helm directory](server/helm/urlcache-helm)
2.  Execute below command to upgraded or install the Helm chart (which has service and deployments) named `urlcache-service` into the Kubernetes cluster, creating the namespace `urlcache-namespace` if it doesn't exist, using the Helm chart located in the current directory.
```bash
helm upgrade --install urlcache-service -n urlcache-namespace --create-namespace .
```
3. Check the created with below command
```bash
 kubectl get services -n urlcache-namespace
```
Example output:
```bash
NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE
urlcache-service-urlcache-helm   ClusterIP   10.106.116.37   <none>        11211/TCP   9m49s
```

You received `urlcache-service-urlcache-helm` as your service name which can be used by client to connect with it.
*to stop later you can use `helm uninstall urlcache-service -n urlcache-namespace`*
**b. for backend server**
1. Navigate to backend server's [server/helm/urlserver-helm directory](server/helm/urlserver-helm)
2. Execute below command to upgraded or install the Helm chart (which has service and deployments) named `urlserver-service` into the Kubernetes cluster, creating the namespace `urlserver-namespace` if it doesn't exist, using the Helm chart located in the current directory.
```bash
helm upgrade --install urlserver-service -n urlserver-namespace --create-namespace .
```
3. Check the created with below command
```bash
 kubectl get services -n urlserver-namespace
```
Example output:
```bash
NAME                               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
urlserver-service-urlserver-helm   ClusterIP   10.105.226.2   <none>        8000/TCP   46m
```

You received `urlserver-service-urlserver-helm` as your service name which can be used by client to connect with it.
*to stop later you can use `helm uninstall urlserver-service -n urlserver-namespace`*

**c. for client**
1. Navigate to client's [client/helm/urlclient-helm directory](client/helm/urlclient-helm)
2. Execute below command to upgraded or install the Helm chart (which has service and deployments) named `urlclient-service` into the Kubernetes cluster, creating the namespace `urlclient-namespace` if it doesn't exist, using the Helm chart located in the current directory.
```bash
helm upgrade --install urlclient-service -n urlclient-namespace --create-namespace .
```

## Notes:
- If you hosted your server on external DNS say EC2 machines, you can update the `DNS` in [utils file](server/utils/utils.py)

  
## Refrences

1. [How to Create a Flask + React Project | Python Backend + React Frontend](https://youtu.be/7LNl2JlZKHA?si=aSMnZdAX7WARyZD3) by [Arpan Neupane](https://youtube.com/@ArpanNeupaneProductions?si=eBabEizliU63fXDV)

2. [Unlocking the Power of NoSQL: FastAPI with MongoDB](https://www.youtube.com/watch?v=QkGqjPFIGCA) by [Eric Roby](https://www.youtube.com/@codingwithroby)

3. [Memcache Fundamentals in Python | Python PyMemcache Tutorial](https://www.youtube.com/watch?v=mPUaQLtWqGs&t=533s) by [Irtiza Hafiz](https://www.irtizahafiz.com/)
   
4. [Dockerize FastAPI project like a pro - Step-by-step Tutorial](https://www.youtube.com/watch?v=CzAyaSolZjY&t=277s) by [Stackless Tech](https://www.youtube.com/@stacklesstech)
   
5. [Complete Kubernetes Course | Deploy MERN app](https://youtu.be/7XDeI5fyj3w?si=tsLIYVPAU2YcFH8T) by [Hitesh Choudhary](http://www.hiteshChoudhary.com)

6. ["Hello, World!" Docker to Kubernetes](https://guptaachin.hashnode.dev/hello-world-to-kubernetes) by [Achin Gupta](https://guptaachin.vercel.app

7. (https://medium.com/@sionabraham95/python-memcached-kuberentes-caching-in-distributed-cloud-native-platforms-e35896a8ef5f)
